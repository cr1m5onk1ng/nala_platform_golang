// Code generated by sqlc. DO NOT EDIT.
// source: post_comments.sql

package db

import (
	"context"
	"time"
)

const addComment = `-- name: AddComment :one
INSERT INTO comments (
  user_id, 
  post_id,
  content
) VALUES (
    $1, $2, $3
) RETURNING id, user_id, post_id, content, comment_time
`

type AddCommentParams struct {
	UserID  string `json:"user_id"`
	PostID  string `json:"post_id"`
	Content string `json:"content"`
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (Comment, error) {
	row := q.queryRow(ctx, q.addCommentStmt, addComment, arg.UserID, arg.PostID, arg.Content)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.Content,
		&i.CommentTime,
	)
	return i, err
}

const addCommentAsResponse = `-- name: AddCommentAsResponse :exec
INSERT INTO comments_responses (
  source_comment_id, 
  response_comment_id
) VALUES( $1, $2 )
`

type AddCommentAsResponseParams struct {
	SourceCommentID   int64 `json:"source_comment_id"`
	ResponseCommentID int64 `json:"response_comment_id"`
}

func (q *Queries) AddCommentAsResponse(ctx context.Context, arg AddCommentAsResponseParams) error {
	_, err := q.exec(ctx, q.addCommentAsResponseStmt, addCommentAsResponse, arg.SourceCommentID, arg.ResponseCommentID)
	return err
}

const getAllPostComments = `-- name: GetAllPostComments :many
SELECT id, user_id, post_id, content, comment_time FROM comments
ORDER BY comment_time DESC
LIMIT $1 OFFSET $2
`

type GetAllPostCommentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPostComments(ctx context.Context, arg GetAllPostCommentsParams) ([]Comment, error) {
	rows, err := q.query(ctx, q.getAllPostCommentsStmt, getAllPostComments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.Content,
			&i.CommentTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserComments = `-- name: GetAllUserComments :many
SELECT id, user_id, post_id, content, comment_time FROM comments
WHERE user_id = $1
ORDER BY comment_time DESC
LIMIT $2 OFFSET $3
`

type GetAllUserCommentsParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllUserComments(ctx context.Context, arg GetAllUserCommentsParams) ([]Comment, error) {
	rows, err := q.query(ctx, q.getAllUserCommentsStmt, getAllUserComments, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.Content,
			&i.CommentTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserPostComments = `-- name: GetAllUserPostComments :many
SELECT id, user_id, post_id, content, comment_time FROM comments
WHERE post_id = $1 AND user_id = $2
ORDER BY comment_time DESC
LIMIT $3 OFFSET $4
`

type GetAllUserPostCommentsParams struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllUserPostComments(ctx context.Context, arg GetAllUserPostCommentsParams) ([]Comment, error) {
	rows, err := q.query(ctx, q.getAllUserPostCommentsStmt, getAllUserPostComments,
		arg.PostID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.Content,
			&i.CommentTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentDirectResponses = `-- name: GetCommentDirectResponses :many
SELECT id, user_id, post_id, content, comment_time, source_comment_id, response_comment_id FROM comments AS c
JOIN comments_responses AS cr
ON c.id = cr.source_comment_id
WHERE c.id = $1
ORDER BY c.comment_time DESC
LIMIT $2 OFFSET $3
`

type GetCommentDirectResponsesParams struct {
	ID     int64 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCommentDirectResponsesRow struct {
	ID                int64     `json:"id"`
	UserID            string    `json:"user_id"`
	PostID            string    `json:"post_id"`
	Content           string    `json:"content"`
	CommentTime       time.Time `json:"comment_time"`
	SourceCommentID   int64     `json:"source_comment_id"`
	ResponseCommentID int64     `json:"response_comment_id"`
}

func (q *Queries) GetCommentDirectResponses(ctx context.Context, arg GetCommentDirectResponsesParams) ([]GetCommentDirectResponsesRow, error) {
	rows, err := q.query(ctx, q.getCommentDirectResponsesStmt, getCommentDirectResponses, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommentDirectResponsesRow{}
	for rows.Next() {
		var i GetCommentDirectResponsesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.Content,
			&i.CommentTime,
			&i.SourceCommentID,
			&i.ResponseCommentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentLikes = `-- name: GetCommentLikes :many
SELECT comment_id, user_id FROM comments_likes
WHERE comment_id = $1
`

func (q *Queries) GetCommentLikes(ctx context.Context, commentID int64) ([]CommentsLike, error) {
	rows, err := q.query(ctx, q.getCommentLikesStmt, getCommentLikes, commentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommentsLike{}
	for rows.Next() {
		var i CommentsLike
		if err := rows.Scan(&i.CommentID, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeComment = `-- name: RemoveComment :exec
DELETE FROM comments
WHERE id = $1
`

func (q *Queries) RemoveComment(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.removeCommentStmt, removeComment, id)
	return err
}

const removePostComments = `-- name: RemovePostComments :exec
DELETE FROM comments
WHERE post_id = $1
`

func (q *Queries) RemovePostComments(ctx context.Context, postID string) error {
	_, err := q.exec(ctx, q.removePostCommentsStmt, removePostComments, postID)
	return err
}

const removeUserComments = `-- name: RemoveUserComments :exec
DELETE FROM comments
WHERE user_id = $1
`

func (q *Queries) RemoveUserComments(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.removeUserCommentsStmt, removeUserComments, userID)
	return err
}
