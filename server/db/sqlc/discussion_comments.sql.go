// Code generated by sqlc. DO NOT EDIT.
// source: discussion_comments.sql

package db

import (
	"context"
	"database/sql"
)

const addComment = `-- name: AddComment :one
INSERT INTO discussion_comments (
  discussion_id, 
  parent_comment_id,
  user_id,
  content
) VALUES (
    $1, $2, $3, $4
) RETURNING id, discussion_id, parent_comment_id, user_id, creation_time, content
`

type AddCommentParams struct {
	DiscussionID    int64         `json:"discussion_id"`
	ParentCommentID sql.NullInt64 `json:"parent_comment_id"`
	UserID          string        `json:"user_id"`
	Content         string        `json:"content"`
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (DiscussionComment, error) {
	row := q.queryRow(ctx, q.addCommentStmt, addComment,
		arg.DiscussionID,
		arg.ParentCommentID,
		arg.UserID,
		arg.Content,
	)
	var i DiscussionComment
	err := row.Scan(
		&i.ID,
		&i.DiscussionID,
		&i.ParentCommentID,
		&i.UserID,
		&i.CreationTime,
		&i.Content,
	)
	return i, err
}

const getAllPostComments = `-- name: GetAllPostComments :many
SELECT id, discussion_id, parent_comment_id, user_id, creation_time, content FROM discussion_comments
ORDER BY creation_time DESC
LIMIT $1 OFFSET $2
`

type GetAllPostCommentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPostComments(ctx context.Context, arg GetAllPostCommentsParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllPostCommentsStmt, getAllPostComments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreationTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserComments = `-- name: GetAllUserComments :many
SELECT id, discussion_id, parent_comment_id, user_id, creation_time, content FROM discussion_comments
WHERE user_id = $1
ORDER BY creation_time DESC
LIMIT $2 OFFSET $3
`

type GetAllUserCommentsParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllUserComments(ctx context.Context, arg GetAllUserCommentsParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllUserCommentsStmt, getAllUserComments, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreationTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserPostComments = `-- name: GetAllUserPostComments :many
SELECT id, discussion_id, parent_comment_id, user_id, creation_time, content FROM discussion_comments
WHERE discussion_id = $1 AND user_id = $2
ORDER BY creation_time DESC
LIMIT $3 OFFSET $4
`

type GetAllUserPostCommentsParams struct {
	DiscussionID int64  `json:"discussion_id"`
	UserID       string `json:"user_id"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) GetAllUserPostComments(ctx context.Context, arg GetAllUserPostCommentsParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllUserPostCommentsStmt, getAllUserPostComments,
		arg.DiscussionID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreationTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentDirectResponses = `-- name: GetCommentDirectResponses :many
SELECT id, discussion_id, parent_comment_id, user_id, creation_time, content FROM discussion_comments AS c
WHERE parent_comment_id = NULL
LIMIT $1 OFFSET $2
`

type GetCommentDirectResponsesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetCommentDirectResponses(ctx context.Context, arg GetCommentDirectResponsesParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getCommentDirectResponsesStmt, getCommentDirectResponses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreationTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentLikes = `-- name: GetCommentLikes :many
SELECT comment_id, user_id FROM comments_likes
WHERE comment_id = $1
`

func (q *Queries) GetCommentLikes(ctx context.Context, commentID int64) ([]CommentsLike, error) {
	rows, err := q.query(ctx, q.getCommentLikesStmt, getCommentLikes, commentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommentsLike{}
	for rows.Next() {
		var i CommentsLike
		if err := rows.Scan(&i.CommentID, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeComment = `-- name: RemoveComment :exec
DELETE FROM discussion_comments
WHERE id = $1
`

func (q *Queries) RemoveComment(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.removeCommentStmt, removeComment, id)
	return err
}

const removeDiscussionComments = `-- name: RemoveDiscussionComments :exec
DELETE FROM discussion_comments
WHERE discussion_id = $1
`

func (q *Queries) RemoveDiscussionComments(ctx context.Context, discussionID int64) error {
	_, err := q.exec(ctx, q.removeDiscussionCommentsStmt, removeDiscussionComments, discussionID)
	return err
}

const removeUserComments = `-- name: RemoveUserComments :exec
DELETE FROM discussion_comments
WHERE user_id = $1
`

func (q *Queries) RemoveUserComments(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.removeUserCommentsStmt, removeUserComments, userID)
	return err
}
