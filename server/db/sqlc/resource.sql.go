// Code generated by sqlc. DO NOT EDIT.
// source: resource.sql

package db

import (
	"context"
)

const addResource = `-- name: AddResource :one
INSERT INTO resources (
  url, 
  language, 
  difficulty,
  media_type, 
  category
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, url, language, difficulty, media_type, category
`

type AddResourceParams struct {
	Url        string `json:"url"`
	Language   string `json:"language"`
	Difficulty string `json:"difficulty"`
	MediaType  string `json:"media_type"`
	Category   string `json:"category"`
}

func (q *Queries) AddResource(ctx context.Context, arg AddResourceParams) (Resource, error) {
	row := q.queryRow(ctx, q.addResourceStmt, addResource,
		arg.Url,
		arg.Language,
		arg.Difficulty,
		arg.MediaType,
		arg.Category,
	)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Language,
		&i.Difficulty,
		&i.MediaType,
		&i.Category,
	)
	return i, err
}

const getResourceById = `-- name: GetResourceById :one
SELECT id, url, language, difficulty, media_type, category FROM resources
WHERE id = $1
`

func (q *Queries) GetResourceById(ctx context.Context, id int64) (Resource, error) {
	row := q.queryRow(ctx, q.getResourceByIdStmt, getResourceById, id)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Language,
		&i.Difficulty,
		&i.MediaType,
		&i.Category,
	)
	return i, err
}

const getResourceByUrl = `-- name: GetResourceByUrl :one
SELECT id, url, language, difficulty, media_type, category FROM resources
WHERE url = $1 
LIMIT 1
`

func (q *Queries) GetResourceByUrl(ctx context.Context, url string) (Resource, error) {
	row := q.queryRow(ctx, q.getResourceByUrlStmt, getResourceByUrl, url)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Language,
		&i.Difficulty,
		&i.MediaType,
		&i.Category,
	)
	return i, err
}

const getResourcePost = `-- name: GetResourcePost :one
SELECT id, user_id, resource_id, post_time, post_title, post_description FROM user_post
WHERE resource_id = $1
LIMIT 1
`

func (q *Queries) GetResourcePost(ctx context.Context, resourceID int64) (UserPost, error) {
	row := q.queryRow(ctx, q.getResourcePostStmt, getResourcePost, resourceID)
	var i UserPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.PostTime,
		&i.PostTitle,
		&i.PostDescription,
	)
	return i, err
}

const getResourcesByLanguage = `-- name: GetResourcesByLanguage :many
SELECT id, url, language, difficulty, media_type, category FROM resources
WHERE language = $1
ORDER BY id DESC LIMIT $2
`

type GetResourcesByLanguageParams struct {
	Language string `json:"language"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) GetResourcesByLanguage(ctx context.Context, arg GetResourcesByLanguageParams) ([]Resource, error) {
	rows, err := q.query(ctx, q.getResourcesByLanguageStmt, getResourcesByLanguage, arg.Language, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Language,
			&i.Difficulty,
			&i.MediaType,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourcesByLanguageByCursor = `-- name: GetResourcesByLanguageByCursor :many
SELECT id, url, language, difficulty, media_type, category FROM resources
WHERE language = $1
AND id < $2
ORDER BY id DESC LIMIT $3
`

type GetResourcesByLanguageByCursorParams struct {
	Language   string `json:"language"`
	Cursor     int64  `json:"cursor"`
	Maxresults int32  `json:"maxresults"`
}

func (q *Queries) GetResourcesByLanguageByCursor(ctx context.Context, arg GetResourcesByLanguageByCursorParams) ([]Resource, error) {
	rows, err := q.query(ctx, q.getResourcesByLanguageByCursorStmt, getResourcesByLanguageByCursor, arg.Language, arg.Cursor, arg.Maxresults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Language,
			&i.Difficulty,
			&i.MediaType,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourcesPostsByUser = `-- name: GetResourcesPostsByUser :many
SELECT r.id, r.url, r.language, r.difficulty, r.media_type, r.category FROM resources AS r
JOIN user_post AS p
ON r.id = p.resource_id
WHERE p.user_id = $1
ORDER BY id DESC LIMIT $2
`

type GetResourcesPostsByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetResourcesPostsByUser(ctx context.Context, arg GetResourcesPostsByUserParams) ([]Resource, error) {
	rows, err := q.query(ctx, q.getResourcesPostsByUserStmt, getResourcesPostsByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Language,
			&i.Difficulty,
			&i.MediaType,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResource = `-- name: UpdateResource :one
UPDATE resources
SET url = $2, language = $3, difficulty = $4, media_type = $5, category = $6
WHERE id = $1
RETURNING id, url, language, difficulty, media_type, category
`

type UpdateResourceParams struct {
	ID         int64  `json:"id"`
	Url        string `json:"url"`
	Language   string `json:"language"`
	Difficulty string `json:"difficulty"`
	MediaType  string `json:"media_type"`
	Category   string `json:"category"`
}

func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) (Resource, error) {
	row := q.queryRow(ctx, q.updateResourceStmt, updateResource,
		arg.ID,
		arg.Url,
		arg.Language,
		arg.Difficulty,
		arg.MediaType,
		arg.Category,
	)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Language,
		&i.Difficulty,
		&i.MediaType,
		&i.Category,
	)
	return i, err
}
