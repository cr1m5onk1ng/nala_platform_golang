// Code generated by sqlc. DO NOT EDIT.
// source: discussion_comments.sql

package db

import (
	"context"
)

const addComment = `-- name: AddComment :one
INSERT INTO discussion_comments (
  discussion_id, 
  parent_comment_id,
  user_id,
  content
) VALUES (
    $1, $2, $3, $4
) RETURNING id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content
`

type AddCommentParams struct {
	DiscussionID    int64  `json:"discussion_id"`
	ParentCommentID int64  `json:"parent_comment_id"`
	UserID          string `json:"user_id"`
	Content         string `json:"content"`
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (DiscussionComment, error) {
	row := q.queryRow(ctx, q.addCommentStmt, addComment,
		arg.DiscussionID,
		arg.ParentCommentID,
		arg.UserID,
		arg.Content,
	)
	var i DiscussionComment
	err := row.Scan(
		&i.ID,
		&i.DiscussionID,
		&i.ParentCommentID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Content,
	)
	return i, err
}

const getAllDiscussionComments = `-- name: GetAllDiscussionComments :many
SELECT id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content FROM discussion_comments
WHERE discussion_id = $1
ORDER BY id DESC LIMIT $2
`

type GetAllDiscussionCommentsParams struct {
	DiscussionID int64 `json:"discussion_id"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) GetAllDiscussionComments(ctx context.Context, arg GetAllDiscussionCommentsParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllDiscussionCommentsStmt, getAllDiscussionComments, arg.DiscussionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDiscussionCommentsByCursor = `-- name: GetAllDiscussionCommentsByCursor :many
SELECT id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content FROM discussion_comments
WHERE discussion_id = $1
AND id < $2
ORDER BY id DESC LIMIT $3
`

type GetAllDiscussionCommentsByCursorParams struct {
	Discussionid int64 `json:"discussionid"`
	Cursor       int64 `json:"cursor"`
	Maxresults   int32 `json:"maxresults"`
}

func (q *Queries) GetAllDiscussionCommentsByCursor(ctx context.Context, arg GetAllDiscussionCommentsByCursorParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllDiscussionCommentsByCursorStmt, getAllDiscussionCommentsByCursor, arg.Discussionid, arg.Cursor, arg.Maxresults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserComments = `-- name: GetAllUserComments :many
SELECT id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content FROM discussion_comments
WHERE user_id = $1
ORDER BY creation_time DESC
LIMIT $2 OFFSET $3
`

type GetAllUserCommentsParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllUserComments(ctx context.Context, arg GetAllUserCommentsParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllUserCommentsStmt, getAllUserComments, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserPostComments = `-- name: GetAllUserPostComments :many
SELECT id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content FROM discussion_comments
WHERE discussion_id = $1 AND user_id = $2
ORDER BY creation_time DESC
LIMIT $3 OFFSET $4
`

type GetAllUserPostCommentsParams struct {
	DiscussionID int64  `json:"discussion_id"`
	UserID       string `json:"user_id"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) GetAllUserPostComments(ctx context.Context, arg GetAllUserPostCommentsParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getAllUserPostCommentsStmt, getAllUserPostComments,
		arg.DiscussionID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentDirectResponses = `-- name: GetCommentDirectResponses :many
SELECT id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content FROM discussion_comments AS c
WHERE parent_comment_id = NULL
LIMIT $1 OFFSET $2
`

type GetCommentDirectResponsesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetCommentDirectResponses(ctx context.Context, arg GetCommentDirectResponsesParams) ([]DiscussionComment, error) {
	rows, err := q.query(ctx, q.getCommentDirectResponsesStmt, getCommentDirectResponses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscussionComment{}
	for rows.Next() {
		var i DiscussionComment
		if err := rows.Scan(
			&i.ID,
			&i.DiscussionID,
			&i.ParentCommentID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentLikes = `-- name: GetCommentLikes :many
SELECT comment_id, user_id FROM comments_likes
WHERE comment_id = $1
`

func (q *Queries) GetCommentLikes(ctx context.Context, commentID int64) ([]CommentsLike, error) {
	rows, err := q.query(ctx, q.getCommentLikesStmt, getCommentLikes, commentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommentsLike{}
	for rows.Next() {
		var i CommentsLike
		if err := rows.Scan(&i.CommentID, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentLikesCount = `-- name: GetCommentLikesCount :one
SELECT COUNT(*) 
FROM comments_likes
WHERE comment_id = $1
`

func (q *Queries) GetCommentLikesCount(ctx context.Context, commentID int64) (int64, error) {
	row := q.queryRow(ctx, q.getCommentLikesCountStmt, getCommentLikesCount, commentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDiscussionCommentById = `-- name: GetDiscussionCommentById :one
SELECT id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content FROM discussion_comments
WHERE id = $1
`

func (q *Queries) GetDiscussionCommentById(ctx context.Context, id int64) (DiscussionComment, error) {
	row := q.queryRow(ctx, q.getDiscussionCommentByIdStmt, getDiscussionCommentById, id)
	var i DiscussionComment
	err := row.Scan(
		&i.ID,
		&i.DiscussionID,
		&i.ParentCommentID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Content,
	)
	return i, err
}

const likeComment = `-- name: LikeComment :exec
INSERT INTO comments_likes (
  comment_id,
  user_id
) VALUES (
  $1, $2
)
`

type LikeCommentParams struct {
	CommentID int64  `json:"comment_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) LikeComment(ctx context.Context, arg LikeCommentParams) error {
	_, err := q.exec(ctx, q.likeCommentStmt, likeComment, arg.CommentID, arg.UserID)
	return err
}

const removeComment = `-- name: RemoveComment :exec
DELETE FROM discussion_comments
WHERE id = $1
`

func (q *Queries) RemoveComment(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.removeCommentStmt, removeComment, id)
	return err
}

const removeDiscussionComments = `-- name: RemoveDiscussionComments :exec
DELETE FROM discussion_comments
WHERE discussion_id = $1
`

func (q *Queries) RemoveDiscussionComments(ctx context.Context, discussionID int64) error {
	_, err := q.exec(ctx, q.removeDiscussionCommentsStmt, removeDiscussionComments, discussionID)
	return err
}

const removeUserComments = `-- name: RemoveUserComments :exec
DELETE FROM discussion_comments
WHERE user_id = $1
`

func (q *Queries) RemoveUserComments(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.removeUserCommentsStmt, removeUserComments, userID)
	return err
}

const unlikeComment = `-- name: UnlikeComment :exec
DELETE FROM comments_likes
WHERE comment_id = $1
AND user_id = $2
`

type UnlikeCommentParams struct {
	CommentID int64  `json:"comment_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) UnlikeComment(ctx context.Context, arg UnlikeCommentParams) error {
	_, err := q.exec(ctx, q.unlikeCommentStmt, unlikeComment, arg.CommentID, arg.UserID)
	return err
}

const updateComment = `-- name: UpdateComment :one
UPDATE discussion_comments
SET content = $2, updated_at = now()
WHERE id = $1
RETURNING id, discussion_id, parent_comment_id, user_id, created_at, updated_at, content
`

type UpdateCommentParams struct {
	ID      int64  `json:"id"`
	Content string `json:"content"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (DiscussionComment, error) {
	row := q.queryRow(ctx, q.updateCommentStmt, updateComment, arg.ID, arg.Content)
	var i DiscussionComment
	err := row.Scan(
		&i.ID,
		&i.DiscussionID,
		&i.ParentCommentID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Content,
	)
	return i, err
}
